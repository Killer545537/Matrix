\input{C.tex}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}
\title{Matrix Multiplication}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\huge Project Work \vfil
			Matrices and their Operations in Python\\
			
		\end{center}
	\end{titlepage}
	\tableofcontents
	\newpage
	
	\begin{abstract}
		Matrices are a part of Linear Algebra which is used everywhere in Computer Science. It is used in computer graphics to create 2D/3D models, animations, etc. It is used in cryptography (making data secure) by using matrices to store data and a key matrix to encrypt it and its inverse to decrypt it. In this project we will look at operations on matrices in Python.
	\end{abstract}
	\section{What is a Matrix?}
	A matrix is a rectangular array of data\footnote{Data may be of any form, like numbers, expressions or alphabets.} arranged in rows and columns.\\
	A matrix looks like the following:
	\[A=\begin{bmatrix}
		1 & 10 & 12 \\
		2&20& 22
	\end{bmatrix}_{2\times 3}\]
	A matrix is represented by capital letters and the subscript represents $\text{Number of rows}\times \text{Number of columns}$ and the matrix $A$ is called \emph{a 2 by 3 matrix}.\\
	In Python, to enter a matrix, we use nested lists like: 
	\begin{lstlisting}[language=Python]
Matrix=[
	[1,10,12],
	[2,10,22]
]\end{lstlisting}
	\subsection{Accessing a Matrix}
	A matrix a is generally written as $A=[a_{ij}]_{m\times n}$ where $1\leq i\leq m \land 1\leq j \leq n$. Thus, if we know the location of an element say, \emph{element in row 2 and column 1}, we can write it as $a_{21}$.
	In Python as well, if we need to find the \emph{element in row i and column j}, we can return it as:
	\begin{lstlisting}[language=Python]
def find_element(matrix, row, column):
	row_index=row-1 #we need to use row-1 as indexes begin from 0
	column_index=column-1
	return matrix[row_index][column_index] \end{lstlisting}	
	\begin{eg}
		We can also access the elements of a matrix, either row or column wise.
	\end{eg}
	\begin{explanation}
		To print the matrix row-wise:
		\begin{lstlisting}[language=Python]
def row_wise(matrix):
	for i in range(len(matrix)):
		for j in range(len(matrix[0])):
			print(matrix[i][j],end="\t")
	print("\n") \end{lstlisting}
	If matrix is $A=\begin{bmatrix}
		1 & 10 & 12 \\
		2&20& 22
	\end{bmatrix}$, then, the output is,
	\begin{verbatim}
1       10      12

2       20      22
	\end{verbatim}
		To print the matrix column-wise:
	\begin{lstlisting}[language=Python]
def column_wise(matrix):
	for i in range(len(matrix[0])):
		for j in range(len(matrix)):
			print(matrix[j][i],end="\t")
	print("\n") \end{lstlisting}
	The output in this case is:
	\begin{verbatim}
		1       2
		
		10      20
		
		12      22
	\end{verbatim}
	\end{explanation}
	\subsection{Null Matrix}
	A null matrix is one such that,
	\[a_{ij}=0 \quad \forall \ i,j\]
	Such a matrix is represented by $O$.
	\begin{eg}
		Creating a null matrix of a given order.
	\end{eg}
	\begin{explanation} \phantom \\
		\begin{lstlisting}[language=Python]
def null(rows,columns):
	null_matrix=[[0 for i in range(columns)] for i in range(rows)] #loop over columns then over rows
	return null_matrix \end{lstlisting}
	\end{explanation}

	\subsection{Upper and Lower Triangular Matrices}
	The upper triangular matrix is a matrix in which all the entries below the diagonal are zero, i.e.,
	\[a_{ij}=0\quad \forall \ i\geq j\]
	Or,
	\[A=\begin{bmatrix}
		a_{11} & a_{12} & \dots & a_{1n}\\
		0 & a_{22} & \dots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots \\
		0& 0& \cdots & a_{nn}
	\end{bmatrix}\]
	The lower triangular matrix is a matrix in which all the entries above the diagonal are zero\footnote{These definitions are open for discussion. Some authors claim that the matrix must be square, while some do not restrict the matrix. Even though a 'triangle' would not be formed in the case of rectangular matrices, it is acceptable. We have chosen not to restrict the matrices to only square matrices.}, i.e.,
	\[a_{ij}=0\quad \forall \ i\leq j\]
	Or,
	\[A=\begin{bmatrix}
		a_{11}& 0 & \dots & 0\\
		a_{21}& a_{22} & \dots & 0\\
		\vdots & \vdots & \ddots & 0\\
		a_{n1}& a_{n2}& \dots & a_{nn}
	\end{bmatrix}\]
	\begin{eg}
		Creating an upper and lower triangular matrix.
	\end{eg}
	\begin{explanation}
		First for an upper triangular matrix,
		\begin{lstlisting}[language=Python]
def upper_triangular(matrix):
    rows=len(matrix)
    columns=len(matrix[0])
    upper_matrix=null(rows,columns) #null matrix
    for i in range(rows):
        for j in range(columns):
            if i>=j: #Condition for a null matrix
                upper_matrix[i][j]+=matrix[i][j]
            else:
                continue
    return upper_matrix \end{lstlisting}
	If the matrix is $A=\begin{bmatrix}
		1 & 2& 3\\
		4& 5& 6
	\end{bmatrix}$, then, the output is,
	\begin{verbatim}
		[[1, 0, 0], [4, 5, 0]]
	\end{verbatim}
	Now, for a lower triangular matrix,
	\begin{lstlisting}[language=Python]
def lower_triangular(matrix):
	rows=len(matrix)
	columns=len(matrix[0])
	lower_matrix=null(rows,columns) #null matrix
	for i in range(rows):
		for j in range(columns):
			if j>=i: #Condition for a null
				lower_matrix[i][j]+=matrix[i][j]
			else:
				continue
	return lower_matrix \end{lstlisting}
	The output in this case is,
	\begin{verbatim}
		[[1, 2, 3], [0, 5, 6]]
	\end{verbatim}
	\end{explanation}
	\subsection{Transpose of a Matrix}
	The transpose of a matrix $A=[a_{ij}]_{m\times n}$ is given by,
	\[A^T=[a_{ji}]_{n\times m}\]
	\begin{eg}
		Create another matrix which is the transpose of a given matrix.
	\end{eg}
	\begin{explanation}\phantom \\
		\begin{lstlisting}[language=Python]
def transpose(matrix):
	rows=len(matrix)
	columns=len(matrix[0])
	transpose_matrix=null(columns, rows) #null matrix
	for i in range(rows):
		for j in range(columns):
			transpose_matrix[j][i]+=matrix[i][j] #definition of transpose

	return transpose_matrix \end{lstlisting}
	If the matrix is $A=\begin{bmatrix}
		1&2&3\\
		4&5&6\\
		1&1&1
	\end{bmatrix}$
	\end{explanation}, the output is,
	\begin{verbatim}
		[[1, 4, 1], [2, 5, 1], [3, 6, 1]]
	\end{verbatim}
	\subsection{Addition of Two Matrices}
	Given two matrices $A=[a_{ij}]_{n_1\times m_1}$ and $B=[b_{ij}]_{n_2\times m_2}$, the sum $A+B$ is defined only if $(n_1,m_1)=(n_2,m_2)=(n,m) \ (\text{Say})$, i.e. the matrices have the same order.
	\[C=A+B=[a_{ij}+b_{ij}]_{n\times m}\]\
	\begin{eg}
		Find the sum of two matrices.
	\end{eg}
	\begin{explanation}
		It returns the sum of the matrices if it exists, else, returns -1.\\
		\begin{lstlisting}[language=Python]
def Matrix_Sum(matrix1,matrix2):
    if len(matrix1)==len(matrix2) and len(matrix1[0])==len(matrix2[0]): #Checking for compatibility for addition
        rows, columns=len(matrix1), len(matrix1[0])
        sum_matrix=null(rows,columns) #null matrix
        for i in range(rows):
            for j in range(columns):
                sum_matrix[i][j]+=matrix1[i][j]+matrix2[i][j] #definition of sum of matrices
        return sum_matrix
    else:
        return -1 \end{lstlisting}
		If the input matrices are $A=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
			1&1&1
		\end{bmatrix}$ and $B=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
			2&2&2
		\end{bmatrix}$, the output is,
		\begin{verbatim}
			[[2, 4, 6], [8, 10, 12], [3, 3, 3]]
		\end{verbatim}
		If the matrices are $A=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
			1&1&1
		\end{bmatrix}$ and $B=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
		\end{bmatrix}$, the output is,\\
		-1
	\end{explanation}
	\subsection{Subtraction of Two Matrices}
	Matrices also have am additive inverse, i.e., there exists a matrix $B$ such that,
	\[A+B=0\implies B=-A\]
	The matrix $B$ is defined as $B=[-a_{ij}]_{n\times m}$ if the matrix $A$ js defined as $A=[a_{ij}]_{n\times m}$.\\
	Thus, we can define the operation $A-B$ as $A+(-B)$ which is simple matrix addition.
	\begin{eg}
		Find the difference of two matrices.
	\end{eg}
	\begin{explanation}
		It is similar to the sum of two matrices program.
		\begin{lstlisting}[language=Python]
def Matrix_Difference(matrix1,matrix2):
#The program is matrix1-matrix2, since subtraction is not commutative
matrix2_new=null(len(matrix2),len(matrix2[0]))
for i in range(len(matrix2)):
	for j in range(len(matrix2[0])):
		matrix2_new[i][j]=-matrix2[i][j] #From the definition of the negative of a matrix
return(Matrix_Sum(matrix1,matrix2_new))#From the definition of difference of two matrices
		\end{lstlisting}
		If the input matrices are $A=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
			1&1&1
		\end{bmatrix}$ and $B=\begin{bmatrix}
			1&2&3\\
			4&5&6\\
			2&2&2
		\end{bmatrix}$, the output is, \begin{verbatim}
			[[0, 0, 0], [0, 0, 0], [-1, -1, -1]]
		\end{verbatim}
	\end{explanation}
	\section{Division of a Matrix by a Scalar}
	When a matrix is divided by a scalar, each element of the matrix is reduced by a factor of the scalar, i.e.,
	\[\frac{A}{k}=\left[\frac{a_{ij}}{k}\right]\]
	\begin{eg}
		Find the result of a matrix divided by a scalar.
	\end{eg}
	\begin{explanation}
		Using the above definition,
		\begin{lstlisting}[language=Python]
def Division(mx, scalar: int):
    new_matrix = null(len(mx), len(mx[0]))
    for i in range(len(mx)):
        for j in range(len(mx[0])):
            new_matrix[i][j] += mx[i][j] / scalar
    return new_matrix \end{lstlisting}
	\end{explanation}
	\subsection{Minor Matrix of an Element}
	The minor matrix of an element is the matrix obtained from removing the $i^{\text{th}}$ row and $j^{\text{th}}$ column of a matrix.\
	\begin{eg}
		Find the minor matrix of a matrix given the location of the matrix,
	\end{eg}
	\begin{explanation}
		For this, first we exclude the $i^{\text{th}}$ row. Then, we exclude the $j^{\text{th}}$ column \footnotetext{The following is an incredible one-liner.}.
		\begin{lstlisting}[language=Python]
def Minor_Matrix(mx,r,c):
    return [row[:c]+row[c+1:] for row in (mx[:r]+mx[r+1:])] \end{lstlisting}
	\end{explanation}
	\subsection{Determinant of a Matrix}
	The determinant is a scalar value that is a function of the entries of a square matrix. It is denoted by $det(A)$, $|A|$ or $\Delta$.\\
	If $A=\begin{bmatrix}
		a_{11} & a_{12}\\
		a_{21} & a_{22}
	\end{bmatrix}$ then, $\Delta =a_{11}a_{22}-a_{21}a_{12}$.\\
	If $A=\begin{bmatrix}
		a_{11} & a_{12}& a_{13}\\
		a_{21} & a_{22}& a_{23}\\
		a_{31}& a_{32}& a_{33}
	\end{bmatrix}$ then, $\Delta=a_{11}\begin{vmatrix}
	a_{22}& a_{23}\\
	a_{32}& a_{33}
	\end{vmatrix}+a_{22}\begin{vmatrix}
	a_{21}& a_{23}\\
	a_{31}& a_{33}
	\end{vmatrix}+a_{33}\begin{vmatrix}
	a_{21}& a_{22}\\
	a_{31}& a_{32}
	\end{vmatrix}$\\
	Before finding the determinant of a matrix, let us look at Cofactors.
	\subsubsection{Cofactors}
	The cofactor of an element $a_{ij}$ is denoted by $A_{ij}$ and is given by,
	\[A_{ij}=(-1)^{i+j}M_{ij}\]
	Where, $M_{ij}$ is the determinant of the minor matrix of the element $a_{ij}$.
	The determinant of a matrix is thus given by,
	\[\Delta=\sum\limits_{j=0}^n a_{1j}A_{1j}\]
	Thus, the determinant of a matrix is the sum of the elements multiplied with their cofactors.
	\begin{eg}
		Find the determinant of a matrix.
	\end{eg}
	\begin{explanation}
		Since we have a closed form for the determinant of a $2\times 2$ matrix, we can reduce all determinants\footnote{So, we need to use recursion.} to finding the determinant of a smaller matrix by using cofactors.
		\begin{lstlisting}[language=Python]
			def Determinant(mx):
			# for the base case when the matrix is 2*2
			if len(mx) == 2:
				return mx[0][0] * mx[1][1] - mx[0][1] * mx[1][0]
			determinant = 0
			# We will only expand along the first row
			for i in range(len(mx)):
				determinant += (
					((-1) ** i) * mx[0][i] * Determinant(Minor_Matrix(mx, 0, i))
				)  # By definition
			return determinant \end{lstlisting}
	\end{explanation}
	\section{Inverse of a Matrix}
	If $A$ is a square matrix of order $m$, and there exists another square matrix $B$ of the same order $m$, such that $AB=BA=I$, then $B$ is called the inverse matrix of $A$ and it is denoted by $A^{-1}$. In that case $A$ is said to be invertible. The inverse of a matrix if it exists is unique.\
	\subsection{Adjoint of a Matrix}
	The adjoint of a square matrix $A=[a_{ij}]_{n\cross n}$ is defined as the transpose of the matrix $[A_{ij}]_{n\cross n}$, i.e.,
	\[ \text{adj} \ A=[A_{ij}]_{n\cross n}\]
	\begin{eg}
		Find the adjoint of a matrix.
	\end{eg}
	\begin{explanation} \phantom \\
		\begin{lstlisting}[language=Python]
def Adjoint(mx):
    temp_matrix = []  # Empty matrix before the transpose
    for i in range(len(mx)):
        row = []  # Initialise each row
        for j in range(len(mx)):
            row.append(
                ((-1) ** (i + j)) * Determinant(Minor_Matrix(mx, i, j))
            )  # from the definition of adjoint
        temp_matrix.append(row)
    return transpose(temp_matrix) \end{lstlisting}
	\end{explanation}
	The inverse of a matrix can be calculated by using:
	\[A^{-1}=\frac{1}{|A|}\text{adj} \ A\]
	\begin{eg}
		Find the inverse of a matrix.
	\end{eg}
	\begin{explanation}
		Using the above definition,
		\begin{lstlisting}[language=Python]
def Inverse(mx):
	if Determinant(mx) == 0:
		return None  # The inverse does not exist in this case
	else:
		return Division(Adjoint(mx), Determinant(mx))  # By definition \end{lstlisting}
	\end{explanation}



\end{document}